<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Andrdoid--自定义控件]]></title>
      <url>%2F2017%2F09%2F28%2FAndroid--%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[Android–自定义控件 自定义属性 自定义控件(写类) 使用自定义控件 自定义属性如何自定义属性呢？res/attrs.xml (没有的先创建一个attrs.xml) 自定义控件 1.创建一个java并继承已有的组件 这种自定义控件的方式又叫组合控件，或者说是在原有控件的基础之上升级控件,还有一种方式是完全的自定义View 1public class TopBar extends RelativeLayout &#123;&#125; 2.声明属性并找到属性2.1声明属性1234567891011121314// 左边需要的属性 private String leftTitle; private int leftColor; private Drawable leftBackground; // 中间需要的属性 private String midTitle; private int midColor; private float midTitleSize; // 右边需要的属性 private String rightTitle; private int rightColor; private Drawable rightBackground; 2.2 找到属性这就需要构造函数,因为我继承的是RelativeLayout，所以用此演示。这里选择带有属性的构造函数。 1234567891011121314151617181920public TopBar(Context context, AttributeSet attrs) &#123; super(context, attrs); // 把自定义属性放到TypeArray的数据结构中 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TopBar); // 从TypedArray 数据结构中获取我们的xml自定义的属性，格式为 TopBar_XXX TopBar为declare-styleable的name值 XXX使我们自定义的属性名称 leftTitle = typedArray.getString(R.styleable.TopBar_leftText); leftColor = typedArray.getColor(R.styleable.TopBar_leftTextColor, 0); leftBackground = typedArray.getDrawable(R.styleable.TopBar_leftBackground); rightTitle = typedArray.getString(R.styleable.TopBar_rightText); rightColor = typedArray.getColor(R.styleable.TopBar_rightTextColor, 0); rightBackground = typedArray.getDrawable(R.styleable.TopBar_rightBackground); midTitle = typedArray.getString(R.styleable.TopBar_title); midColor = typedArray.getColor(R.styleable.TopBar_titleTextColor, 0); midTitleSize = typedArray.getDimension(R.styleable.TopBar_titleTextSize, 0); // 不要忘记recycle typedArray.recycle(); &#125; 3.声明控件并为控件设置属性我们声明的属性干嘛的？ 我们把属性取出来又为了什么？玩？ 不可能！ 没错就是为控件所用的，那么我们需要控件啊，所以我们要声明控件！就声明两个Button 和一个TextView吧 3.1 声明控件1234// 声明控件 private Button leftButton; private Button rightButton; private TextView midTitleView; 3.2为控件设置属性1234567891011121314151617181920 // 创建 控件 leftButton = new Button(context); rightButton = new Button(context); midTitleView = new TextView(context); // 为控件添加我们的自定义的属性 leftButton.setTextColor(leftColor); leftButton.setBackground(leftBackground); leftButton.setText(leftTitle); rightButton.setTextColor(rightColor); rightButton.setBackground(rightBackground); rightButton.setText(rightTitle); midTitleView.setText(midTitle); midTitleView.setTextColor(midColor); midTitleView.setTextSize(midTitleSize); midTitleView.setGravity(Gravity.CENTER);// 这是View的方法。只要是View都会生效的，写这句话的作用是仅仅为了设置背景。 setBackgroundColor(Color.parseColor("#8D6E63")); 4.设置LayoutParams（布局参数）什么？你不知道什么是LayoutParams，来来来，请参考别人网友写的LayoutParams 顺便看看LayoutParams的大家族 解释 LayoutParams： LayoutParams 可以理解为layout的包信息(参数)，其中包含了各种数据（参数）。变量param 定义了宽， 高。然后把这个作为Child View的参数了。这很好的体现了LayoutParams的作用。 4.1声明LayoutParams1234//LayoutParams private LayoutParams leftParams; private LayoutParams rightParams; private LayoutParams titleParams; 4.2设置LayoutParams1234567891011121314151617// 使用LayoutParams // 定义宽高，我这里使用的是ViewGroup.LayoutParams leftParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); // 定义放置规则，左对齐 leftParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT, TRUE); // addView 是ViewGroup的方法 // Adds a child view with the specified layout parameters. //把控件添加到我们的ViewGroup。 addView(leftButton, leftParams); rightParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); rightParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, TRUE); addView(rightButton, rightParams); titleParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); titleParams.addRule(RelativeLayout.CENTER_IN_PARENT); addView(midTitleView, titleParams); 5. 设置监听事件 这里需要用到接口回调的设计思想 1234567891011121314151617// 声明一个TopBarClickListener 接口的实例 private TopBarClickListener listener; // 定义回调接口 public interface TopBarClickListener &#123; void leftClick(); void rightClick(); &#125; // 暴露一个设置监听的方法给用户 // 这里传入的参数是接口参数，由于接口不能直接创建对象，我们想要使用接口，那么就需要实现它的方法，也就是匿名内部类的方式。 public void setOnTopBarClickListener(TopBarClickListener listener) &#123; // 神奇的地方就是在于我们的参数是接口参数 this.listener = listener; &#125; 123456789101112131415//定义View点击事件 leftButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.leftClick();//接口引用+接口方法 &#125; &#125;); rightButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.rightClick();//接口引用+接口方法 &#125; &#125;); 6.扩展方法(添加想要的API)我们可以为我们的控件添加我们任何想要的功能方法(就是所谓的API)，这样使用我们控件的人就可以调用方法了。 123456789//添加暴露方法，相当于给TopBar创建很多的API方法，这样可以对控件进行各种想要的控制//这里添加一个隐藏左边button的方法 public void setLeftButtonIsvisable(boolean flag) &#123; if (flag) &#123; leftButton.setVisibility(View.VISIBLE); &#125; else &#123; leftButton.setVisibility(View.GONE); &#125; &#125; 6.1完整的TopBar控件代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package me.microcool.customview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Color;import android.graphics.drawable.Drawable;import android.util.AttributeSet;import android.view.Gravity;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.RelativeLayout;import android.widget.TextView;/** * Created by gaoshiwei on 2017/9/23. */public class TopBar extends RelativeLayout &#123; // 左边需要的属性 private String leftTitle; private int leftColor; private Drawable leftBackground; // 中间需要的属性 private String midTitle; private int midColor; private float midTitleSize; // 右边需要的属性 private String rightTitle; private int rightColor; private Drawable rightBackground; // 声明控件 private Button leftButton; private Button rightButton; private TextView midTitleView; //LayoutParams private LayoutParams leftParams; private LayoutParams rightParams; private LayoutParams titleParams; // 声明一个TopBarClickListener 接口的实例 private TopBarClickListener listener; // 定义回调接口 public interface TopBarClickListener &#123; void leftClick(); void rightClick(); &#125; // 暴露一个设置监听的方法给用户 // 这里传入的参数是接口参数，由于接口不能直接创建对象，我们想要使用接口，那么就需要实现它的方法，也就是匿名内部类的方式。 public void setOnTopBarClickListener(TopBarClickListener listener) &#123; // 神奇的地方就是在于我们的参数是接口参数 this.listener = listener; &#125; public TopBar(Context context, AttributeSet attrs) &#123; super(context, attrs); // 把自定义属性放到TypeArray的数据结构中 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TopBar); // 从TypedArray 数据结构中获取我们的xml自定义的属性，格式为 TopBar_XXX TopBar为declare-styleable的name值 XXX使我们自定义的属性名称 leftTitle = typedArray.getString(R.styleable.TopBar_leftText); leftColor = typedArray.getColor(R.styleable.TopBar_leftTextColor, 0); leftBackground = typedArray.getDrawable(R.styleable.TopBar_leftBackground); rightTitle = typedArray.getString(R.styleable.TopBar_rightText); rightColor = typedArray.getColor(R.styleable.TopBar_rightTextColor, 0); rightBackground = typedArray.getDrawable(R.styleable.TopBar_rightBackground); midTitle = typedArray.getString(R.styleable.TopBar_title); midColor = typedArray.getColor(R.styleable.TopBar_titleTextColor, 0); midTitleSize = typedArray.getDimension(R.styleable.TopBar_titleTextSize, 0); // 不要忘记recycle typedArray.recycle(); // 创建 控件 leftButton = new Button(context); rightButton = new Button(context); midTitleView = new TextView(context); // 为控件添加我们的自定义的属性 leftButton.setTextColor(leftColor); leftButton.setBackground(leftBackground); leftButton.setText(leftTitle); rightButton.setTextColor(rightColor); rightButton.setBackground(rightBackground); rightButton.setText(rightTitle); midTitleView.setText(midTitle); midTitleView.setTextColor(midColor); midTitleView.setTextSize(midTitleSize); midTitleView.setGravity(Gravity.CENTER); // 这是View的方法。只要是View都会生效的，写这句话的作用是仅仅为了设置背景。 setBackgroundColor(Color.parseColor("#8D6E63")); // 使用LayoutParams // 定义宽高 leftParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); // 定义放置规则，左对齐 leftParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT, TRUE); // addView 是ViewGroup的方法 Adds a child view with the specified layout parameters. //把控件添加到我们的ViewGroup。 addView(leftButton, leftParams); rightParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); rightParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, TRUE); addView(rightButton, rightParams); titleParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); titleParams.addRule(RelativeLayout.CENTER_IN_PARENT); addView(midTitleView, titleParams); //定义View点击事件 leftButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.leftClick();//接口引用+接口方法 &#125; &#125;); rightButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.rightClick(); &#125; &#125;); &#125; //添加暴露方法，相当于给TopBar创建很多的API方法，这样可以对控件进行各种想要的控制 public void setLeftButtonIsvisable(boolean flag) &#123; if (flag) &#123; leftButton.setVisibility(View.VISIBLE); &#125; else &#123; leftButton.setVisibility(View.GONE); &#125; &#125;&#125; 7.使用自定义控件7.1引进xml布局文件中1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="me.microcool.customview.CustomHomeActivity"&gt; &lt;me.microcool.customview.TopBar android:id="@+id/top_bar" android:layout_width="match_parent" android:layout_height="40dp" app:leftBackground="@color/colorAccent" app:leftText="@string/nav_back" app:leftTextColor="@color/colorPrimary" app:rightBackground="@color/colorAccent" app:rightText="@string/more" app:rightTextColor="@color/colorPrimary" app:title="@string/title" app:titleTextColor="@color/colorPrimaryDark" app:titleTextSize="@dimen/title_text_size" /&gt;&lt;/RelativeLayout&gt; 7.2在活动中使用自定义的控件123456789101112131415161718192021222324252627282930313233343536373839package me.microcool.customview;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.Toast;public class CustomHomeActivity extends AppCompatActivity &#123; private TopBar mTopBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; actionBar.hide(); &#125; setContentView(R.layout.activity_custom_home); initView(); &#125; private void initView() &#123; mTopBar = (TopBar) findViewById(R.id.top_bar); mTopBar.setOnTopBarClickListener(new TopBar.TopBarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(CustomHomeActivity.this, "LeftButton", Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(CustomHomeActivity.this, "RightButton", Toast.LENGTH_SHORT).show(); &#125; &#125;); mTopBar.setLeftButtonIsvisable(true); &#125;&#125; 8.一点额外的知识 请注意： xmlns:android=”http://schemas.android.com/apk/res/android“ xmlns:app=”http://schemas.android.com/apk/res-auto“ xmlns(xmlnamespace) 我们之所以能用 android：XXXX12345678910android:layout_width="match_parent"android:layout_height="40dp"``` 是因为AS自动为我们添加xmlns:android="http://schemas.android.com/apk/res/android"#### 当我们使用自定义的属性的时候，就需要使用自己的命名空间。```xmlxmlns:app="http://schemas.android.com/apk/res-auto" 一般用app这个名字，当然我们也可以自定义,比如起个custom的名字。 12xmlns:custom="http://schemas.android.com/apk/res-auto"&lt;!--但是后面一定要是 http://schemas.android.com/apk/res-auto --&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Andrdoid--PopupWindow]]></title>
      <url>%2F2017%2F09%2F24%2FPopupWindow%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[PopupWindow的学习使用参考链接 Android PopupWindow的使用和分析 Android PopupWindow详解 浅谈PopupWindow在Android开发中的使用 Google: A popup window that can be used to display an arbitrary view. The popupwindow is a floating container that appears on top of the current activity.” 就是说PopupWindow是一个以弹窗方式呈现的控件，可以用来显示任意视图(View)，而且会浮动在当前活动(activity)的顶部”。因此我们可以通过PopupWindow实现各种各样的弹窗效果,进行信息的展示或者是UI交互，由于PopupWindow自定义布局比较方便，而且在显示位置比较自由不受限制，因此受到众多开发者的青睐。 在Android中弹出式菜单（以下称弹窗）是使用十分广泛一种菜单呈现的方式，弹窗为用户交互提供了便利。关于弹窗的实现大致有以下两种方式AlertDialog和PopupWindow，当然网上也有使用Activity并配合Dialog主题的方式实现弹窗，有兴趣的朋友也可以去研究一下。对于AlertDialog和PopupWindow两者的最主要区别就是显示的位置问题： 位置是否固定。 AlertDialog在位置显示上是固定的，而PopupWindow则相对比较随意，能够在主屏幕上的任意位置显示。 1.PopupWindow的使用PopupWindow 是一个类其实PopupWindow的使用非常简单，总的来说分为两步： 调用PopupWindow的构造器创建PopupWindow对象，并完成一些初始化设置。 调用PopupWindow的showAsDropDown(View view)将PopupWindow作为View组件的下拉组件显示出来；或调用PopupWindow的showAtLocation()方法将PopupWindow在指定位置显示出来。 12345678910PopupWindow popupWindow = new PopupWindow(this);//这里选择其中的一个构造方法。popupWindow.setWidth(ViewGroup.LayoutParams.WRAP_CONTENT);popupWindow.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);popupWindow.setContentView(LayoutInflater.from(this).inflate(R.layout.layout_popupwindow_style01, null));popupWindow.setBackgroundDrawable(new ColorDrawable(0x00000000));popupWindow.setOutsideTouchable(false);popupWindow.setFocusable(true);// 最省事的方式。PopupWindow mPopupWindow = new PopupWindow(viewContent, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true); 其中，setWidth、setHeight和setContentView三者必须实现，否则将不会显示任何视图。 setwidth和setHeight的参数值可以是具体的数值，也可以是MATCH_PARENT或者是WRAP_CONTENT。 setContentView则是为PopupWindow设置视图内容。 setFocusable顾名思义就是让PopupWindow获得焦点。 setBackgroundDrawable从字面理解就是为PopupWindow设置一个背景.(最好设置背景，可以为透明。) setOutsideTouchable则表示PopupWindow内容区域外的区域是否响应点击事件，Android官方给出的文档则表示点击内容区域外的区域是否关闭窗口，那么设置为true应该就是表示关闭，设置为false就是表示不关闭咯！ 那么我们就动手试一下吧，验证一下是不是和我们想象的相吻合： 2.PopupWindow的显示：PopupWindow的显示大致又可以分为两类：相对于视图中某个控件的相对位置(默认位于控件的正左下方)和相对于父控件的相对位置； 相对于视图中某个控件的相对位置： 123showAsDropDown(View anchor)：相对某个控件的位置（正左下方），无偏移。showAsDropDown(View anchor, int xoff, int yoff)：相对某个控件的位置，同时可以设置偏移。showAsDropDown(View anchor, int xoff, int yoff, int gravity)：相对某个控件的位置，对齐方式（尝试过，但似乎没有效果），同时可以设置偏移。 相对于父控件的相对位置： 1showAtLocation(View parent, int gravity, int x, int y)：相对于父控件的位置，同时可以设置偏移量。 3.添加动画PopupWindow的动画 很多时候我们把PopupWindow用作自定义的菜单，需要一个从底部向上弹出的效果，这就需要为PopupWindow添加动画。设置动画的方法： 12345678910public void setAnimationStyle(int animationStyle)``` 在res/value/styles.xml添加一个sytle```xml&lt;style name="anim_menu_bottombar"&gt; &lt;item name="android:windowEnterAnimation"&gt;@anim/menu_bottombar_in&lt;/item&gt; &lt;item name="android:windowExitAnimation"&gt;@anim/menu_bottombar_out&lt;/item&gt;&lt;/style&gt; 在工程res下新建anim文件夹，在anim文件夹先新建两个xml文件 12345678&lt;!-- menu_bottombar_in.xml --&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="250" android:fromYDelta="100.0%" android:toYDelta="0.0" /&gt;&lt;/set&gt; 12345678&lt;!-- menu_bottombar_out.xml --&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="250" android:fromYDelta="0.0" android:toYDelta="100%" /&gt;&lt;/set&gt; 设置上动画 1mPopupWindow.setAnimationStyle(R.style.menu_anim_bottombar);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Andrdoid-- 样式开发 selector]]></title>
      <url>%2F2017%2F09%2F24%2FAndroid--Selector%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Android样式开发–selector 参考 ： 重点看Google的文档 https://keeganlee.me/post/android/20150905 什么是selector？ Google: Color State List Resource 我就认为他是颜色选择器（Color-Selector）。 为什么要使用selector？ shape只能定义单一的形状，而实际应用中，很多地方比如按钮、Tab、ListItem等都是不同状态有不同的展示形状。举个例子，一个按钮的背景，默认时是一个形状，按下时是一个形状，不可操作时又是另一个形状。有时候，不同状态下改变的不只是背景、图片等，文字颜色也会相应改变。而要处理这些不同状态下展示什么的问题，就要用selector来实现了。 –说明自自Keegan小钢 如何创建？创建在哪里？ 看这里 res/color/filename.xml(没有color文件夹的先在res下新建个color文件夹) 【这里说的是主要使用方式】 下面是Google文档中给的demo 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:color="hex_color" android:state_pressed=["true" | "false"] android:state_focused=["true" | "false"] android:state_selected=["true" | "false"] android:state_checkable=["true" | "false"] android:state_checked=["true" | "false"] android:state_enabled=["true" | "false"] android:state_window_focused=["true" | "false"] /&gt;&lt;/selector&gt; selector标签selector标签，可以添加一个或多个item子标签，而相应的状态是在item标签中定义的。 定义的xml文件可以作为两种资源使用：drawable和color。 作为drawable资源使用时，一般和shape一样放于drawable目录下，item必须指定android:drawable属性； 作为color资源使用时，则放于color目录下，item必须指定android:color属性。 item标签看看都有哪些状态可以设置呢： android:state_enabled: 设置触摸或点击事件是否可用状态，一般只在false时设置该属性，表示不可用状态 android:state_pressed: 设置是否按压状态，一般在true时设置该属性，表示已按压状态，默认为false android:state_selected: 设置是否选中状态，true表示已选中，false表示未选中 android:state_checked: 设置是否勾选状态，主要用于CheckBox和RadioButton，true表示已被勾选，false表示未被勾选 android:state_checkable: 设置勾选是否可用状态，类似state_enabled，只是state_enabled会影响触摸或点击事件，而state_checkable影响勾选事件 android:state_focused: 设置是否获得焦点状态，true表示获得焦点，默认为false，表示未获得焦点 android:state_window_focused: 设置当前窗口是否获得焦点状态，true表示获得焦点，false表示未获得焦点，例如拉下通知栏或弹出对话框时，当前界面就会失去焦点；另外，ListView的ListItem获得焦点时也会触发true状态，可以理解为当前窗口就是ListItem本身 有二个文档中没写的(参考自上面的链接)： android:state_activated: 设置是否被激活状态，true表示被激活，false表示未激活，API Level 11及以上才支持，可通过代码调用控件的setActivated(boolean)方法设置是否激活该控件 android:state_hovered: 设置是否鼠标在上面滑动的状态，true表示鼠标在上面滑动，默认为false，API Level 14及以上才支持 Google Demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Andrdoid--Shape]]></title>
      <url>%2F2017%2F09%2F24%2FAndroid--Shape%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Android样式开发 –Shape 参考： https://keeganlee.me/post/android/20150830 https://developer.android.com/guide/topics/resources/drawable-resource.html 说明在Android开发中，使用shape可以很方便的帮我们画出想要的背景，相对于png图片来说，使用shape可以减少安装包的大小，而且能够更好的适配不同的手机。 Shape放在哪里？请统一放在res/drawable下 如何编写自己的shape文件？ 创建shape_xxx.xml文件 root element 为shape 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 官方的Demo --&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape=["rectangle" | "oval" | "line" | "ring"] &gt; &lt;corners android:radius="integer" android:topLeftRadius="integer" android:topRightRadius="integer" android:bottomLeftRadius="integer" android:bottomRightRadius="integer" /&gt; &lt;gradient android:angle="integer" android:centerX="integer" android:centerY="integer" android:centerColor="integer" android:endColor="color" android:gradientRadius="integer" android:startColor="color" android:type=["linear" | "radial" | "sweep"] android:useLevel=["true" | "false"] /&gt; &lt;padding android:left="integer" android:top="integer" android:right="integer" android:bottom="integer" /&gt; &lt;size android:width="integer" android:height="integer" /&gt; &lt;solid android:color="color" /&gt; &lt;stroke android:width="integer" android:color="color" android:dashWidth="integer" android:dashGap="integer" /&gt;&lt;/shape&gt; 谈谈标签 solid：填充颜色 corners：圆角大小。 padding：设置内边距。 stroke: 不填充(其实就是线条) gradient 渐变 这里面已经列出了所有的shape属性。 Shape 能做什么？android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] android:shape=&quot;xxxx&quot; xxxx就是我们可以绘制的图形 这里可以看出，shape可以画四种图形，分别是：矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。 Demo 矩形（rectangle）直角矩形1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!--填充颜色--&gt; &lt;solid android:color="@color/colorPrimary" /&gt;&lt;/shape&gt; 圆角矩形1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!--圆角大小--&gt; &lt;corners android:radius="10dp"&gt;&lt;/corners&gt; &lt;!--填充颜色--&gt; &lt;solid android:color="@color/colorPrimary"&gt;&lt;/solid&gt; &lt;!--设置内边距--&gt; &lt;padding android:bottom="12dp" android:left="12dp" android:right="12dp" android:top="12dp"&gt;&lt;/padding&gt;&lt;/shape&gt; 注意 关于圆角的设置更多的说明。 12345android:radius="integer" android:topLeftRadius="integer" android:topRightRadius="integer" android:bottomLeftRadius="integer" android:bottomRightRadius="integer" android:radius：表示4个角的圆角大小； 还可以分别设置四个角的，使用下面四个属性： android:topLeftRadius 左上 android:topRightRadius 右上 android:bottomLeftRadius 左下 android:bottomRightRadius 右下 无填充带边框矩形12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;corners android:radius="10dp"&gt;&lt;/corners&gt; &lt;padding android:bottom="12dp" android:left="12dp" android:right="12dp" android:top="12dp"&gt;&lt;/padding&gt; &lt;stroke android:width="5dp" android:color="@color/colorAccent"&gt;&lt;/stroke&gt; &lt;!--stroke android:width：边框大小 android:color：边框颜色--&gt;&lt;/shape&gt; 渐变矩形123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;solid android:color="@color/colorPrimary"&gt;&lt;/solid&gt; &lt;padding android:bottom="12dp" android:left="12dp" android:right="12dp" android:top="12dp"&gt;&lt;/padding&gt; &lt;gradient android:startColor="@android:color/white" android:endColor="@android:color/black" android:angle="0"&gt;&lt;/gradient&gt;&lt;/shape&gt; gradient： android:startColor：渐变起始颜色 android:endColor：渐变结束颜色 android:angle：渐变角度： 0:左到右; 90:下到上; 180:右到左; 270:上到下; 谈谈三种渐变的type sweep 扫描渐变 linear 线性渐变 radial 辐射渐变 椭圆（oval）画圆 纯色的圆123456789&lt;!--size的height和width设置为一样大小就是一个圆了--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;solid android:color="@color/colorPrimary" /&gt; &lt;size android:width="50dp" android:height="50dp" /&gt;&lt;/shape&gt; 渐变的圆12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;size android:width="50dp" android:height="50dp" /&gt; &lt;gradient android:centerX="0.5" android:centerY="0.5" android:endColor="@color/colorAccent" android:startColor="@color/colorPrimary" android:type="sweep" /&gt;&lt;/shape&gt; android:centerX：表示渐变的X轴起始位置，范围0-1，0.5表示圆心。 android:centerY：表示渐变的Y轴起始位置，范围0-1，0.5表示圆心。 android:type：渐变类型，有三种 linear 线性渐变，默认的渐变类型 radial 放射渐变，设置该项时，android:gradientRadius也必须设置 sweep 扫描性渐变 线（line）123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="line"&gt; &lt;stroke android:width="1dp" android:color="@color/colorAccent" android:dashGap="3dp" android:dashWidth="4dp"&gt;&lt;/stroke&gt; &lt;size android:height="3dp"&gt;&lt;/size&gt;//可以不用设置&lt;/shape&gt; 线是居中显示的。 android:width：填充颜色的高度 android:dashGap：虚线间距宽度 android:dashWidth：虚线宽度 圆环（ring）普通圆环123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="ring" android:useLevel="false" android:thickness="10dp"&gt; &lt;!--android:thickness：圆环宽度--&gt; &lt;!--useLevel需要设置为false--&gt; &lt;solid android:color="@color/colorAccent"&gt;&lt;/solid&gt;&lt;/shape&gt; 渐变圆环12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="ring" android:useLevel="false" android:thickness="10dp"&gt; &lt;!--useLevel需要设置为false--&gt; &lt;solid android:color="@color/colorAccent"&gt;&lt;/solid&gt; &lt;gradient android:startColor="@color/colorAccent" android:endColor="@color/colorPrimary" android:type="sweep"&gt;&lt;/gradient&gt;&lt;/shape&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Activity&Fragment生命周期详解]]></title>
      <url>%2F2017%2F07%2F29%2FActivity%E5%92%8CFragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Activity&amp;Fragment生命周期详解 生命周期，是初学Android必须要掌握的一个知识点，也是面试时最常问的知识点。个人觉得，设计Android的工程师们，很大程度上参考了IOS。 1. Activity生命周期介绍Activity生命周期共有7个，可以按照3+1的模式去记忆。 这是一张标准的生命周期示意图，从上图中可以看出，onCreate&lt;–&gt;onDestory，onStart&lt;–&gt;onStop，onResume&lt;–&gt;onPause 成对，多出一个onRestart。 启动一个Activity，会依次执行onCreate（创建一个Activity时调用，可通常在此处指定Activity的布局或动态设置Activity主题）、onStart（启动这个Activity时调用，此时Activity已经可以见，但是未获得焦点不能响应用户事件）、onResume（Activity获取焦点时调用，此时可以响应用户事件）方法。 通常调用onPause（Activity停止响应用户事件，在切换Activity、锁屏、弹出dialog，准确说是Dialog风格的Activity，普通的dialog是属于Activity的，生命周期不变化、按下Home键时调用）方法之后，很快就会调用onStop（Activity不可见，已经停止时调用，Activity再次恢复可见状态时，需要重新调用onRestart方法）方法。当调转一个dialog 主题的Activity时，前一个Activity只会进入pause状态，而不会触发onStop。 执行onStop方法之后，若需要再使该Activity可用，先调用onRestart（重新启动Activity，该Activity实例占用的内存还未被释放，无须重走onCreate方法）再调用onStart、onResume。 Activity被销毁时，会执行onDestory（释放Activity实例占用的内存，等待系统回收。或强制中断APP进程时调用。），此时标志这个这个Activity生命周期完整的结束。 综上，Activity生命周期又可以分为三类： onCreate—&gt;onDestory，整体生命周期 onStart—&gt;onStop，可视生命周期 onResume—&gt;onPause，焦点生命周期 2. 切换Activity时生命的周期变化2.1、跳转 相同颜色表示同一个Activity。跳转到下一个Activity或返回到上一个Activity时，都会使当前Activity失去焦点（onPause）。当前Activity获取焦点时（onResume），再去处理上一个Activity的onStop方法，是否调用onDestory方法由Activity栈、或系统根据此时内存情况决定。 2.2 按返回（Back）键按返回键，会调用Activity的finish方法，首先会执行onPause，如果Activity栈中还有activity，就执行这个activity的onRestart方法，若没有则继续执行onStop–&gt;onDestory。 2.3 按home键按下home键，通常会将应用切到后台，执行onPause–&gt;onStop方法。当内存不够时，系统会根据一定策略选择杀死一个应用进程，或者用户手动杀死这个应用进行都会导致之前的activity执行了onDestory方法。 实际开发中，是无法通过onKeyDown 捕获Home键按下的事件（捕获Back键是可以的），经过上述分析得知，按下Home键和返回键不同的地方是在于有没有调用finish方法。因此在执行onStop方法时，可以通过判断是否执行了finish方法，进而判断按下的是否是home键。此处注意区分按下锁屏键效果同按下Home键。 3. Fragment生命周期介绍 这依旧是一张经典的fragment生命周期示意图。相比Activity中，7个生命周期的方法，fragment生命周期共涉及到11个方法，记忆和理解起来有一定的难度。此处推荐4+4+3记忆方式。先看下图： 这张图凸显出，Activity和Fragment之间生命周期的关联。在弄懂Activity生命周期的前提上，去理解Fragment生命周期有着事半功倍的效果。 启动Activity时，如果Activity中已绑定了Fragment，那么也会同步创建Fragment。创建Fragment时，会连续执行4个生命周期方法：onAttach（同Activity绑定），onCreate（创建Fragment实例），onCreateView（创建Fragment视图），onActivityCreated（Activity创建完成）。 接下来的4个生命周期将和Activity的四个同名生命周期交替执行。如：先执行Fragment的onStart 再执行Activity 的onStart，继续执行Activity的onResume 到Fragment 的onResume，自此Activity已经完成启动过程，绑定的fragment也已经显示，并能够获取到焦点响应用户事件。切换Activity：先执行Fragment的onPause到Activity的onPause再执行Fragment的onStop到Activity的onStop。此时，Activity连同Fragment已经失去焦点且已经不可见。 结束Activity时，会连续执行Fragment的三个生命周期：onDestoryView（销毁Fragment视图），onDestory（销毁Fragment实例），onDetach（与Activity解绑）。最后执行Activity的onDestory，表示Activity已经销毁。 上述中，若Activity绑定多个Fragment，那么多个Fragment的相同生命周期一定是交替执行了，除了虚线框内标记的是连续执行。 4. 切换Fragment时生命周期的变化加载fragment有两种方式 1234567891011121314&lt;!-- 方式一 --&gt;&lt;fragment android:id="@+id/top_fragment" android:name="com.flueky.frameworktest.fragment.TopFragment" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" /&gt;&lt;!-- 方式二 --&gt;&lt;FrameLayout android:id="@id/fragment_contain" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"/&gt; 方式一类似于添加一个控件，程序运行时不可以动态修改。其中，name属性是用户定义fragment类完整的类名（包括包名），id或tag属性则是在代码中通过findFragmentById或findFragmentByTag获取到fragment对象。并且，该fragment生命周期同其所在的Activity生命周期绑定。 方式二指定一个fragment容器，程序运行时可以通过replace 或add 方法动态加载指定的fragment。动态加载fragment，需要考虑到fragment切换时，fragment生命周期的变化。只要不切换Activity，fragment生命周期改变时，Activity生命周一直处于onResume状态。 切换fragment 可以通过replace 或add方式，与此同时，考虑到是否将fragment 入栈管理，所以切换fragment共有四种场景。当不入栈时，replace 和add 生命周期变化很相似，因此放在一起讨论。 4.1 replace/add fragment 不入栈不入栈时，表示切换fragment之后，并不保存之前fragment 实例的引用。因此也就无法再操作之前的fragment。add 和replace 的区别是，replace会将之前的fragment移除，重新添加一个fragment，add 则在之前fragment之上再添加一个fragment，倘若被add fragment的背景是透明的，依然会看见之前fragment的样式。 通过上图的周期流程图中，不难发现replace 和add 的区别。 4.2 replace fragment 入栈此时替换fragment时，首先会移除当前fragment的视图（onDestoryView），但是没有删除当前fragment的实例（没有调用onDestory和onDetach），因为该fragment已经入栈（依然保留着fragment实例的引用）。然后再添加新的fragment，直到新fragment获取到焦点（执行到onResume）截止。若按下返回键，会移除栈顶的fragment，也就是当前可见的fragment，使下一层fragment可见。但是需要再次初始化页面（执行onCreateView）。 4.3 add fragment 入栈这种场景最简单，切换fragment后，新的fragment在栈顶，点击返回时，将栈顶的fragment出栈，使下面的fragment可见。因为add方式是叠加的，所以之前的fragment依旧是可见的，生命周期没有任何变化。 4.4 replace 和 add fragment 入栈的异同点相同点：由于入栈是可返回的，因此切换和返回就完整的执行了一个fragment的全部生命周期。 不同点：replace方式会消除之前fragment的视图，当之前的fragment再次回到栈顶，会再次调用onCreateView，初始化页面，包括所有用户数据。 之前看博主的这篇文章，博客的主题看着很不舒服，故自己按照博主的文章，重新排版了一下，不能让这么好的文章因为视觉而埋没。原文链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中长度单位的认识]]></title>
      <url>%2F2017%2F05%2F11%2FAndroid%E4%B8%AD%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%2F</url>
      <content type="text"><![CDATA[Android中长度单位的认识dp、sp、px、in、pt、mm 建议尽量使用dp作为空间大小单位，sp作为和文字相关大小单位。 px px（Pixels ，像素）：表示屏幕实际的像素。例如，320*480的屏幕在横向有320个像素，在纵向有480个像素。 inin（Inches ，英寸）：表示英寸，是屏幕的物理尺寸。每英寸等于2.54厘米。例如，形容手机屏幕大小，经常说，3.2（英）寸、3.5（英）寸、4（英）寸就是指这个单位。这些尺寸是屏幕的对角线长度。如果手机的屏幕是3.2英寸，表示手机的屏幕（可视区域）对角线长度是3.2*2.54 = 8.128厘米。读者可以去量一量自己的手机屏幕，看和实际的尺寸是否一致。 mmmm（Millimeters ，毫米）：表示毫米，是屏幕的物理尺寸。 ptpt（Points ，磅）：表示一个点，是屏幕的物理尺寸。大小为1英寸的1/72。 dpdp（与密度无关的像素）：逻辑长度单位，在 160 dpi 屏幕上，1dp=1px=1/160英寸。随着密度变化，对应的像素数量也变化，但并没有直接的变化比例。dip：与dp相同，多用于Google示例中。 spsp（与密度和字体缩放度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。 理解一下dp spdp也就是dip。这个和sp基本类似。如果设置表示长度、高度等属性时可以使用dp 或sp。但如果设置字体，需要使用sp。dp是与密度无关，sp除了与密度无关外，还与scale无关。如果屏幕密度为160，这时dp和sp和px是一样的。1dp=1sp=1px，但如果使用px作单位，如果屏幕大小不变（假设还是3.2寸），而屏幕密度变成了320。那么原来TextView的宽度设成160px，在密度为320的3.2寸屏幕里看要比在密度为160的3.2寸屏幕上看短了一半。但如果设置成160dp或160sp的话。系统会自动将width属性值设置成320px的。也就是160 * 320 / 160。其中320 / 160可称为密度比例因子。也就是说，如果使用dp和sp，系统会根据屏幕密度的变化自动进行转换。 参考郭霖的第一行代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Gilde的基本用法]]></title>
      <url>%2F2017%2F05%2F06%2FGlide%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[GlideGlide的基本用法使用Glide，首先需要将这个库引入到我们的项目当中1234dependencies &#123; compile 'com.github.bumptech.glide:glide:3.7.0'//如何引入版本参考github&#125; 加载图片1Glide.with(this).load(url).into(imageView); 解释一下此代码 with() 首先，调用Glide.with()方法用于创建一个加载图片的实例。with()方法可以接收Context、Activity或者Fragment类型的参数。也就是说我们选择的范围非常广，不管是在Activity还是Fragment中调用with()方法，都可以直接传this。那如果调用的地方既不在Activity中也不在Fragment中呢？也没关系，我们可以获取当前应用程序的ApplicationContext，传入到with()方法当中。注意with()方法中传入的实例会决定Glide加载图片的生命周期，如果传入的是Activity或者Fragment的实例，那么当这个Activity或Fragment被销毁的时候，图片加载也会停止。如果传入的是ApplicationContext，那么只有当应用程序被杀掉的时候，图片加载才会停止。 load() 接下来看一下load()方法，这个方法用于指定待加载的图片资源。Glide支持加载各种各样的图片资源，包括网络图片、本地图片、应用资源、二进制流、Uri对象等等。因此load()方法也有很多个方法重载，除了我们刚才使用的加载一个字符串网址之外，你还可以这样使用load()方法： 12345678910111213141516// 加载本地图片File file = new File(getExternalCacheDir() + "/image.jpg");Glide.with(this).load(file).into(imageView);// 加载应用资源int resource = R.drawable.image;Glide.with(this).load(resource).into(imageView);// 加载二进制流byte[] image = getImageBytes();Glide.with(this).load(image).into(imageView);// 加载Uri对象Uri imageUri = getImageUri();Glide.with(this).load(imageUri).into(imageView); into() 最后看一下into()方法，这个方法就很简单了，我们希望让图片显示在哪个ImageView上，把这个ImageView的实例传进去就可以了。当然，into()方法不仅仅是只能接收ImageView类型的参数，还支持很多更丰富的用法，不过那个属于高级技巧。 那么回顾一下Glide最基本的使用方式，其实就是关键的三步走：先with()，再load()，最后into()。熟记这三步。 扩展用法（其实就是学会使用一些方法） placeholder() diskCacheStrategy() error() asBitmap() asGif() override() 占位图占位图就是指在图片的加载过程中，我们先显示一张临时的图片，等图片加载出来了再替换成要加载的图片。 12345Glide.with(this) .load(url) .placeholder(R.drawable.loading) .into(imageView); 只是在刚才的三步走之间插入了一个placeholder()方法，这个占位图的用法其实也演示了Glide当中绝大多数API的用法，其实就是在load()和into()方法之间串接任意想添加的功能就可以了。当然，这只是占位图的一种，除了这种加载占位图之外，还有一种异常占位图。异常占位图就是指，如果因为某些异常情况导致图片加载失败，比如说手机网络信号不好，这个时候就显示这张异常占位图。 123456Glide.with(this) .load(url) .placeholder(R.drawable.loading) .error(R.drawable.error) .diskCacheStrategy(DiskCacheStrategy.NONE) .into(imageView); 缓存机制主要使用diskCacheStrategy()方法 Glide有非常强大的缓存机制，我们刚才加载那张必应美图的时候Glide自动就已经将它缓存下来了，下次加载的时候将会直接从缓存中读取，不会再去网络下载了，因而加载的速度非常快，所以占位图可能根本来不及显示。 12345Glide.with(this) .load(url) .placeholder(R.drawable.loading) .diskCacheStrategy(DiskCacheStrategy.NONE) .into(imageView); 这里串接了一个diskCacheStrategy()方法，并传入DiskCacheStrategy.NONE参数，这样就可以禁用掉Glide的缓存功能。 指定图片格式我们还需要再了解一下Glide另外一个强大的功能，那就是Glide是支持加载GIF图片的。而使用Glide加载GIF图并不需要编写什么额外的代码，Glide内部会自动判断图片格式。 如果希望指定图片的类型。.asBitmap() 强制指定加载静态图片(动态图片的话，只取第一帧).asGif() 必须加载动态图片（非动图的话，加载失败） 指定图片大小主要使用override()方法使用Glide，我们就完全不用担心图片内存浪费，甚至是内存溢出的问题。因为Glide从来都不会直接将图片的完整尺寸全部加载到内存中，而是用多少加载多少。Glide会自动判断ImageView的大小，然后只将这么大的图片像素加载到内存当中，帮助我们节省内存开支。当然，Glide也并没有使用什么神奇的魔法，它内部的实现原理其实就是上面那篇文章当中介绍的技术，因此掌握了最基本的实现原理，你也可以自己实现一套这样的图片压缩机制。 不过，如果你真的有这样的需求，必须给图片指定一个固定的大小，Glide仍然是支持这个功能的。修改Glide加载部分的代码，如下所示： 1234567Glide.with(this) .load(url) .placeholder(R.drawable.loading) .error(R.drawable.error) .diskCacheStrategy(DiskCacheStrategy.NONE) .override(100, 100) .into(imageView); 这里使用override()方法指定了一个图片的尺寸，也就是说，Glide现在只会将图片加载成100*100像素的尺寸，而不会管你的ImageView的大小是多少了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Andrdoid--Service]]></title>
      <url>%2F2017%2F04%2F26%2FAndroid--Service%2F</url>
      <content type="text"><![CDATA[Android–Service 参考提示：别忘了在 AndroidManifest.xml注册我们定义的服务。 Service是什么？服务（Service）是 Android中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要求长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。 不过需要注意的是, 服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。另外，也不要被服务的后台概念所迷惑，实际上服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞住的情况。 Service分类 封绑定Service 绑定Service 混合型 Service的启动方式有 startService(Intent service) bindService(Intent service, ServiceConnection conn,int flags) 其实看参数我们就可以知道需要什么。 但是，没必要区分这么清 1.使用Service其实就是一个类继承了Service 123456789101112131415161718192021222324252627public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException("Not yet implemented"); &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125; &#125; &#125; Service 的几个方法 onCreate()方法会在服务创建的时候调用。 onBind() 主要用于关联活动与服务。 onStartCommand() 方法会在每次服务启动的时候调用。（主要的逻辑单元方法都是写在这里） onDestroy() 方法会在服务销毁的时候调用。 通常情况下，如果我们希望服务一旦启动就立刻去执行某个动作，就可以将逻辑写在onStartCommand() 方法里。而当服务销毁时，我们又应该在 onDestroy() 方法中去回收那些不再使用的资源。 注册Service每一个服务都需要在AndroidManifest.xml 文件中进行注册才能生效。（这是四大组件共有的的特点） 12345&lt;service android:name=".MyService" android:enabled="true" android:exported="true"&gt; &lt;/service&gt; 启动和停止服务借助Intent 123456Intent startIntent = new Intent(this, MyService.class); startService(startIntent); // 启动服务 Intent stopIntent = new Intent(this, MyService.class); stopService(stopIntent); // 停止服务 // 如果startService()和stopService() 方法都是定义在 Context 类中的，那么可以在活动里可以直接调用这两个方法。 服务不会自己停止如果没有点击Stop Service按钮，服务就会一直处于运行状态。服务启动了之后会一直保持运行状态，直到stopService() 或stopSelf()方法被调用。 注意，虽然每调用一次 startService()方法，onStartCommand() 就会执行一次，但实际上每个服务都只会存在一个实例。所以不管你调用了多少次startService()方法，只需调用一次 stopService() 或stopSelf()方法，服务就会停止下来了。 onCreate()方法和onStartCommand() 方法的区别其实onCreate()方法是在服务第一次创建的时候调用的。而 onStartCommand() 方法则在每次启动服务的时候都会调用。自己写个Demo你就会体会到。（假设我写了一个Demo，View上有两个按钮，一个 Start Service按钮 ，一个Stop Service）当你是第一次点击 Start Service按钮，服务此时还未创建过，所以两个方法都会执行，之后如果你再连续多点击几次 Start Service按钮，你就会发现只有onStartCommand() 方法可以得到执行了。 部分Demo ： 1234567891011121314151617181920212223public class MyService extends Service &#123; ... @Override public void onCreate() &#123; super.onCreate(); Log.d("MyService", "onCreate executed"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d("MyService", "onStartCommand executed"); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("MyService", "onDestroy executed"); &#125; &#125; 2.服务的生命周期之前我们学习过了活动以及碎片的生命周期。类似地，服务也有自己的生命周期，前面我们使用到的 onCreate()、onStartCommand() 、onBind() 和onDestroy() 等方法都是在服务的生命周期内可能回调的方法。 一旦在项目的任何位置调用了 Context的startService()方法，相应的服务就会启动起来，并回调onStartCommand() 方法。如果这个服务之前还没有创建过，onCreate()方法会先于onStartCommand() 方法执行。服务启动了之后会一直保持运行状态，直到stopService() 或stopSelf()方法被调用。 注意，虽然每调用一次 startService()方法，onStartCommand() 就会执行一次，但实际上每个服务都只会存在一个实例。所以不管你调用了多少次startService()方法，只需调用一次 stopService() 或stopSelf()方法，服务就会停止下来了。 另外，还可以调用 Context的bindService() 来获取一个服务的持久连接，这时就会回调服务中的onBind() 方法。类似地，如果这个服务之前还没有创建过，onCreate()方法会先于onBind() 方法执行。之后调用方可以获取到 onBind() 方法里返回的IBinder对象的实例，这样就能自由地和服务进行通信了。只要调用方和服务之间的连接没有断开，服务就会一直保持运行状态。 当调用了startService()方法后，又去调用 stopService() 方法，这时服务中的onDestroy() 方法就会执行，表示服务已经销毁了。类似地，当调用了 bindService() 方法后，又去调用unbindService()方法，onDestroy() 方法也会执行，这两种情况都很好理解。 但是需要注意，我们是完全有可能对一个服务既调用了startService()方法，又调用了bindService() 方法的，这种情况下该如何才能让服务销毁掉呢？根据 Android系统的机制，一个服务只要被启动或者被绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被销毁。所以，这种情况下要同时调用stopService() 和unbindService()方法，onDestroy() 方法才会执行。 这样你就已经把服务的生命周期完整地走了一遍。 3.活动和服务进行通信 (绑定服务) 就是所谓的绑定服务。使用onBind方法实现. 使用需求在活动里成功调用了服务里提供的方法。 有什么办法能让活动和服务的关系更紧密一些呢？例如在活动中指挥服务去干什么，服务就去干什么。这就用到了onBind()方法。 案例比如说，目前我们希望在 MyService里提供一个下载功能，然后在活动中可以决定何时开始下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的 Binder 对象来对下载功能进行管理， 修改 MyService中的代码，如下所示： 1234567891011121314151617181920212223242526public class MyService extends Service &#123; private DownloadBinder mBinder = new DownloadBinder(); class DownloadBinder extends Binder &#123; public void startDownload() &#123; Log.d("MyService", "startDownload executed"); &#125; public int getProgress() &#123; Log.d("MyService", "getProgress executed"); return 0; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; // 看我返回的啥 return mBinder; &#125; ... &#125; 新建了一个 DownloadBinder 类，并让它继承自 Binder，然后在它的内部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功能，我们在这两个方法中分别打印了一行日志。 当一个活动和服务绑定了之后，就可以调用该服务里的 Binder 提供的方法了。 修改代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private MyService.DownloadBinder downloadBinder; // connection private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder = (MyService.DownloadBinder) service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... Button bindService = (Button) findViewById(R.id.bind_service); Button unbindService = (Button) findViewById(R.id.unbind_service); bindService.setOnClickListener(this); unbindService.setOnClickListener(this); &#125; /* 看一下源代码中的bindService @Override public boolean bindService(Intent service, ServiceConnection conn,int flags) &#123; return mBase.bindService(service, conn, flags); &#125; */ @Override public void onClick(View v) &#123; switch (v.getId()) &#123; ... case R.id.bind_service: Intent bindIntent = new Intent(this, MyService.class); bindService(bindIntent, connection, BIND_AUTO_CREATE); // 绑定服务 break; case R.id.unbind_service: unbindService(connection); //解绑服务 break; default: break; &#125; &#125; &#125; 解释代码 这里我们首先创建了一个 ServiceConnection 的匿名类，在里面重写了 onServiceConnected() 方法和onServiceDisconnected() 方法，这两个方法分别会在活动与服务成功绑定以及活动与服务的连接断开的时候调用。 在 onServiceConnected()方法中，我们又通过向下转型得到了 DownloadBinder 的实例，有了这个实例，活动和服务之间的关系就变得非常紧密了。现在我们可以在活动中根据具体的场景来调用DownloadBinder 中的任何public 方法，即实现了指挥服务干什么服务就去干什么的功能。 这里仍然只是做了个简单的测试，在onServiceConnected() 方法中调用了 DownloadBinder 的startDownload()和getProgress() 方法。 当然，现在活动和服务其实还没进行绑定呢，这个功能是在 Bind Service按钮的点击事件里完成的。 可以看到，这里我们仍然是构建出了一个Intent 对象，然后调用 bindService() 方法将MainActivity和MyService进行绑定。 bindService() 方法接收3 个参数。 第一个参数就是刚刚构建出的 Intent 对象。 第二个参数是前面创建出的 ServiceConnection 的实例。 第三个参数则是一个标志位，这里传入 BIND_AUTO_CREATE 表示在活动和服务进行绑定后自动创建服务。（这会使得MyService中的onCreate()方法得到执行，但 onStartCommand() 方法不会执行。） 如果我们想解除活动和服务之间的绑定该怎么办呢？调用一下unbindService()方法就可以了，这也是 Unbind Service按钮的点击事件里实现的功能。 需要注意，任何一个服务在整个应用程序范围内都是通用的，即 MyService不仅可以和MainActivity绑定，还可以和任何一个其他的活动进行绑定，而且在绑定完成后它们都可以获取到相同的DownloadBinder 实例。 4.IntentService为了可以简单地创建一个异步的、会自动停止的服务，Android 专门提供了一个IntentService 类。 存在的意义案例服务中的代码都是默认运行在主线程当中的，如果直接在服务里去处理一些耗时的逻辑，就很容易出现ANR（Application Not Responding）的情况。 这个时候就需要用到 Android多线程编程的技术了，我们应该在服务的每个具体的方法里开启一个子线程，然后在这里去处理那些耗时的逻辑。因此，一个比较标准的服务就可以写成： 12345678910111213141516public class MyService extends Service &#123; ... @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125; &#125; 但是，这种服务一旦启动之后，就会一直处于运行状态，必须调用 stopService() 或者stopSelf()方法才能让服务停止下来。所以，如果想要实现让一个服务在执行完毕后自动停止的功能，就可以这样写： 1234567891011121314151617public class MyService extends Service &#123; ... @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 stopSelf(); //处理完逻辑后自动的停止。 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125; &#125; 但是，尴尬的是。虽说这种写法并不复杂，但是总会有一些程序员忘记开启线程，或者忘记调用 stopSelf()方法。 为了可以简单地创建一个异步的、会自动停止的服务，Android 专门提供了一个IntentService 类，这个类就很好地解决了前面所提到的两种尴尬。 学习使用IntentService123456789101112131415161718public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super("MyIntentService"); // 调用父类的构造函数 &#125; @Override protected void onHandleIntent(Intent intent) &#123; // 打印当前线程的id Log.d("MyIntentService", "Thread id is " + Thread.currentThread(). getId()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("MyIntentService", "onDestroy executed"); &#125; &#125; 解释代码 这里首先要提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数。(这个构造函数是必须写的，不写信不信报错给你看) 然后要在子类中去实现 onHandleIntent() 这个抽象方法，在这个方法中可以去处理一些具体的逻辑，而且不用担心ANR（Application Not Responding）的问题，因为这个方法已经是在子线程中运行的了。这里为了证实一下，我们在onHandleIntent() 方法中打印了当前线程的 id 。 另外根据 IntentService 的特性，这个服务在运行结束后应该是会自动停止的，所以我们又重写了onDestroy() 方法，在这里也打印了一行日志，用来证实服务是不是停止掉了。 前台服务什么？ 还有前台的服务？服务不都是在后台默默运行的吗！但是我们的一些需求需要我们创建一种在前台的服务，这样才不会因为内存不足而把我们的服务杀死。 例如一些天气app简便信息在通知栏常驻，可以方便查看动态变化的天气的信息，那明明是个通知，可为啥子会动态的变化天气信息呢？ 其实这是一个前台服务（哈哈哈哈） Talk is cheap, let me show you the code 123456789101112131415161718192021public class MyService extends Service &#123; ... // Coding in onCreate,这样的话，当startService 或bindService(也就是开启服务的时候，就会创建前台服务) @Override public void onCreate() &#123; super.onCreate(); Log.d("MyService", "onCreate executed"); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is content title") .setContentText("This is content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); startForeground(1, notification); ... &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Andrdoid--使用AsyncTask]]></title>
      <url>%2F2017%2F04%2F26%2FAndroid--AsyncTask%2F</url>
      <content type="text"><![CDATA[Android–AsyncTask AsyncTask一种对异步消息处理机制的封装 参考自第一行代码 参考自码出未来的blog 为了更加方便我们在子线程中对 UI 进行操作，Android 还提供了另外一些好用的工具， 比如 AsyncTask。借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask的实现原理也是基于异步消息处理机制的，只是 Android 帮我们做了很好的封装而已。 AsyncTask 允许对用户界面执行异步操作。 它会先阻塞工作线程中的操作，然后在 UI 线程中发布结果，而无需您亲自处理线程和/或处理程序。 要使用它，必须创建 AsyncTask 的子类并实现 doInBackground() 回调方法，该方法将在后台线程池中运行。要更新 UI，应该实现 onPostExecute() 以传递 doInBackground() 返回的结果并在 UI 线程中运行，以便安全地更新 UI。 可以通过从 UI 线程调用 execute() 来运行任务。 先看一下小Demo 1234567891011121314151617public void onClick(View v) &#123; new DownloadImageTask().execute("http://example.com/image.png");&#125;private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; &#123; /** The system calls this to perform work in a worker thread and * delivers it the parameters given to AsyncTask.execute() */ protected Bitmap doInBackground(String... urls) &#123; return loadImageFromNetwork(urls[0]); &#125; /** The system calls this to perform work in the UI thread and delivers * the result from doInBackground() */ protected void onPostExecute(Bitmap result) &#123; mImageView.setImageBitmap(result); &#125;&#125; 现在 UI 是安全的，代码也得到简化，因为任务分解成了两部分：一部分应在工作线程内完成，另一部分应在 UI 线程内完成。 AsyncTask 使用概述： 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;…&#125; 可以使用泛型指定参数类型、进度值和任务最终值； 方法 doInBackground() 会在工作线程上自动执行； onPreExecute()、onPostExecute() 和 onProgressUpdate() 均在 UI 线程中调用； doInBackground() 返回的值将发送到 onPostExecute()； 可以随时在 doInBackground() 中调用publishProgress()，以在 UI 线程中执行 onProgressUpdate() 注意：使用工作线程时可能会遇到另一个问题，即：运行时配置变更（例如，用户更改了屏幕方向）导致 Activity 意外重启，这可能会销毁工作线程。 要了解如何在这种重启情况下坚持执行任务，以及如何在 Activity 被销毁时正确地取消任务， 下面是详细的讲解 1,AsyncTask基本用法123// 看源码public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;...&#125;//代码的最高境界莫过于自解释代码(自带注释) 首先来看一下 AsyncTask 的基本用法，由于 AsyncTask 是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为 AsyncTask 类指定 3 个泛型参数，这 3 个参数的用途如下。 Params。在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。 Progress。后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的类型作为进度单位。 Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 一个最简单的自定义 AsyncTask 就可以写成如下方式: ```java class DownloadTask extends AsyncTask { … }12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364这里我们把 AsyncTask 的第一个泛型参数指定为 Void，表示在执行 AsyncTask 的时候不需要传入参数给后台任务。第二个泛型参数指定为 Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为 Boolean，则表示使用布尔型数据来反馈执行结果。当然，目前我们自定义的 DownloadTask 还是一个空任务，并不能进行任何实际的操作，我们还需要去重写 AsyncTask 中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下 4个。### 1. onPreExecute()这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。### 2. doInBackground(Params...)**这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。**任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三泛型参数 指定的是 Void，就可以不返回任务执行结果。**注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress (Progress...)方法来完成。**### 3. onProgressUpdate(Progress...)当在后台任务中调用了 publishProgress(Progress...)方法后，onProgressUpdate (Progress...)方法就会很快被调用，`该方法中携带的参数就是在后台任务中传递过来的。` 在这 个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新。### 4. onPostExecute(Result)当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数 据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。### Demo因此，一个比较完整的自定义 AsyncTask 就可以写成如下方式: ```javaclass DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; @Override protected void onPreExecute() &#123; progressDialog.show(); &#125; @Override protected Boolean doInBackground(Void... params) &#123; try &#123; while (true) &#123; int downloadPercent = doDownload(); //这是一个虚构的方法 publishProgress(downloadPercent); if (downloadPercent &gt;= 100) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; // progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;); &#125; @Override protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss(); if (result) &#123; Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot; Download failed&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 启动这个任务如果想要启动这个任务，只需编写以下代码即可: 1new DownloadTask().execute();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Andrdoid--异步消息处理机制]]></title>
      <url>%2F2017%2F04%2F26%2FAndroid--%E8%A7%A3%E6%9E%90%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Android–异步消息处理机制 参考 郭霖blog Android&lt;我所理解的Handler机制&gt; Android 中的异步消息处理主要由 4 个部分组成: Message Handler MessageQueue Looper 1. MessageMessage 是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。 上一小节中我们使用到了 Message 的 what 字段； 除此之外还可以使用 arg1 和 arg2 字段来携带一些整型数据； 使用 obj 字段携带一个 Object 对象。 Demo 123Message message = new Message();message.what = 1;handler.sendMessage(message); 2. HandlerHandler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler的sendMessage()方法，而发出的消息经过一系列地辗转处理后，最终会传递到 Handler 的 handleMessage()方法中。 3. MessageQueueMessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。 4. LooperLooper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop()方法后，就会进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的handleMessage()方法中。每个线程中也只会有一个 Looper 对象。 图解此过程了解了 Message、Handler、MessageQueue 以及 Looper 的基本概念后，我们再来把异步消息处理的整个流程梳理一遍。首先需要在主线程当中创建一个 Handler 对象，并重写 handleMessage()方法。然后当子线程中需要进行 UI 操作时，就创建一个 Message 对象，并通过 Handler 将这条消息发送出去。之后这条消息会被添加到 MessageQueue 的队列中等待被处理， 而 Looper 则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的 handleMessage()方法中。由于 Handler 是在主线程中创建的，所以此时handleMessage()方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行 UI 操作了。 整个异步消息处理机制的流程示意图如图 10.4 所示。 一条 Message 经过这样一个流程的辗转调用后，也就从子线程进入到了主线程，从不能更新 UI 变成了可以更新 UI，整个异步消息处理的核心思想也就是如此。 Demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private TextView textView; public static final int UPDATE_TEXT=1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView=(TextView) findViewById(R.id.text); Button change= (Button) findViewById(R.id.change_text); change.setOnClickListener(this); &#125; /** * Android 异步消息处理. * 使用这种机制就可以出色地解决掉在子线程中更新 UI 的问题。 */ private Handler handler=new Handler()&#123; public void handleMessage(Message msg)&#123; switch (msg.what)&#123; case UPDATE_TEXT:// 在这里可以进行UI操作 textView.setText("nice to meet you "); break; default: break; &#125; &#125; &#125;; @Override public void onClick(View v) &#123; switch(v.getId())&#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; Message message=new Message(); message.what=UPDATE_TEXT; handler.sendMessage(message); // 将 Message 对象发送出去 &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; 一个简单的介绍版本 我(handler)既是消息的发送者，也是消息的处理者。即消息的发送和处理都是handler所为。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Andrdoid--多线程]]></title>
      <url>%2F2017%2F04%2F26%2FAndroid--%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Android多线程编程1.多线程基础如果熟悉Java，对多线程编程一定不会陌生。当我们需要执行一些耗时操作，比如说发起一条网络请求时，考虑到网速等其他原因，服务器未必会立刻响应我们的请求，如果不将这类操作放在子线程里去运行，就会导致主线程被阻塞住，从而影响用户对软件的正常使用。那么就让我们从线程的基本用法开始学习吧。 Android多线程编程其实并不比 Java多线程编程特殊，基本都是使用相同的语法。比如说，定义一个线程只需要新建一个类继承自 Thread，然后重写父类的 run()方法，并在里面编写耗逻辑即可，如下所示： 123456class MyThread extends Thread &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125; &#125; 那么该如何启动这个线程呢？其实也很简单，只需要 new出 MyThread的实例，然后调用它start()方法，这样 run()方法中的代码就会在子线程当中运行了，如下所示： 1new MyThread().start(); 但是，使用继承的方式耦合性有点高，更多的时候我们都会选择使用实现 Runnable 接口的方式来定义一个线程如下所示： 1234567891011121314class MyThread implements Runnable &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125; &#125;``` 如果使用了这种写法，启动线程的方法也需要进行相应的改变，如下所示： ```javaMyThread myThread = new MyThread(); new Thread(myThread).start(); //new Thread(myThread) 可以看到，Thread 的构造函数接收一个 Runnable 参数，而我们new出的 MyThread正是一个实现了 Runnable 接口的对象，所以可以直接将它传入到 Thread 的构造函数里。接着调用Thread 的 start()方法，run()方法中的代码就会在子线程当中运行了。 我常用的写法 如果你不想专门再定义一个类去实现 Runnable 接口，也可以使用匿名类的方式，这种写法更为常见，如下所示： 123456new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125; &#125;).start(); 以上几种线程的使用方式相信你都不会感到陌生，因为在 Java 中创建和启动线程也是使用同样的方式。了解了线程的基本用法后，下面我们来看一下 Android多线程编程与 Java多线程编程不同的地方。 2.在子线程中更新 UI 先说结论： Android 不允许在子线程中进行 UI 操作. 和许多其他的 GUI 库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，则必须在主线程中进行，否则就会出现异常. 有没有解决方案呢？如果有些时候，我们必须在子线程里去执行一些耗时任务，然后根据任务的执行结果来更新相应的 UI 控件，这该如何是好呢？Android提供了一套异步消息处理机制，完美地解决了在子线程中进行 UI 操作的问题。 使用异步消息处理机制 使用AsyncTask runOnUiThread() 第三方方案实现方式(库) 这些内容见bolg]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android--网络技术(二) Okhttp]]></title>
      <url>%2F2017%2F04%2F23%2FAndroid--%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF(%E4%BA%8C)%20Okhttp%2F</url>
      <content type="text"><![CDATA[okhttp入门教程 OkHttp传送门参考鸿洋 1. 添加OkHttp库的依赖编辑app/build.gradle文件，在dependencies闭包中添加 complie &apos;com.squareup.okhttp3:okhttp:XXX.XXX.XXX&apos; XXX是版本号 添加上述依赖会自动下载两个库，一个是 OkHttp 库，一个是 Okio 库，后者是前者的通信基础。 1.先创建一个OkHttpClient的实例首先需要创建一个 OkHttpClient 的实例，如下所示: 1OkHttpClient client = new OkHttpClient(); 2. 创建Request对象接下来如果想要发起一条 HTTP 请求，就需要创建一个 Request 对象: 1Request request = new Request.Builder().build(); 当然，上述代码只是创建了一个空的 Request 对象，并没有什么实际作用，我们可以在最终的 build()方法之前连缀很多其他方法来丰富这个 Request 对象。比如可以通过 url()方法 来设置目标的网络地址，如下所示: 123Request request = new Request.Builder() .url("http://www.baidu.com") .build(); 3, 创建Call对象并发送请求调用 OkHttpClient 的 newCall()方法来创建一个 Call 对象，并调用它的 execute()方法来发送请求并获取服务器返回的数据.写法如下: 1234567891011121314151617181920212223242526/*** okhttp源码* excute 同步执行 阻塞的方式* enqueue 异步执行* Response execute() throws IOException;* 如果使用同步的excute(),发起请求，返回的值是Response类型* 所以声明Response 引用* /Call call = client.newCall(request);Response response = call.execute();//可以简化写：Response response = client.newCall(request).execute();// 异步执行 Call call = client.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;); 4，获取数据其中 Response 对象就是服务器返回的数据了，我们可以使用如下写法来得到返回的具体内容: 123456 String responseData = response.body().string();//onResponse回调的参数是response，一般情况下，//比如我们希望获得返回的字符串，可以通过response.body().string()获取；//如果希望获得返回的二进制字节数组，则调用response.body().bytes()；//如果你想拿到返回的inputStream，则调用response.body().byteStream()//这里说明一点，既然可以拿到流，那么就可以进行IO操作了，可以自己写个文件 5，POST类型的请求如果是发起一条 POST 请求会比 GET 请求稍微复杂一点，我们需要先构建出一个 Request Body 对象来存放待提交的参数，如下所示: RequestBody requestBody = new FormBody.Builder() .add("username", "admin") .add("password", "123456") .build(); 然后在 Request.Builder 中调用一下 post()方法，并将 RequestBody 对象传入: Request request = new Request.Builder() .url("http://www.baidu.com") .post(requestBody) .build(); 接下来的操作就和 GET 请求一样了，调用 execute()方法来发送请求并获取服务器返回的 数据即可。 实战Demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.example.gaoshiwei.myokhttptest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.io.IOException;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest = (Button) findViewById(R.id.send_request); responseText = (TextView) findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.send_request) &#123; sendRequestWithOkHttp(); &#125; &#125; /** * 使用OKhttp */ private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("http://www.baidu.com") .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); showResponse(responseData); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123;// 这里进行UI的操作，将结果显示到界面上 responseText.setText(response); &#125; &#125;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android--网络技术(一) HttpURLConnection]]></title>
      <url>%2F2017%2F04%2F23%2FAndroid--%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF(%E4%B8%80)%20HttpURLConnection%2F</url>
      <content type="text"><![CDATA[Android – HTTP协议访问网络概述： 在Android上我们可以使用WebView访问网络。(主要是配合混合开发)也可以使用HTTP协议来访问网络。有多种选择，有原生的HttpURLConnection，有第三方库如：okhttp，retrofit等 提醒，在开发中，时刻要注意权限的问题。使用网络，是要产生流量数据的，所以别忘了申请网络权限哦。 1.使用HttpURLConnection 在 Android 上使用原生网络api发送 HTTP 请求的方式一般有两种。 HttpURLConnection （官方建议） HttpClient （6.0以后已经移除） (一) HttpURLConnection 的用法。1. 获取 HttpURLConnection 实例首先需要获取到 HttpURLConnection 的实例.一般只需 new 出一个 URL 对象，并传入目标的网络地址，然后调用一下 openConnection()方法即可，如下所示: URL url = new URL(&quot;http://www.baidu.com&quot;);// 先创建URL实例。 HttpURLConnection connection = (HttpURLConnection) url.openConnection();//获取HttpURLConnection实例 2.配置HttpURLConnection 实例 得到了 HttpURLConnection 的实例之后，我们可以设置一下 HTTP 请求所使用的方法。 常用的方法主要有两个，GET 和 POST。GET 表示希望从服务器那里获取数据，而 POST 则表示希望提交数据给服务器。写法如下: 12345678// GET方式connection.setRequestMethod("GET");// POST方式//并在获取输入流之前将要吧提交的数据写出即可。每条数据是键值对形式，数据与数据之间用&amp; 隔开.connection.setRequestMethod("POST");DataOutputStream out=new DataOutputStream(connection.getOutputStream());out.writerByte("username=admin&amp;password=123456"); 3. HttpURLConnection 实例扩展配置接下来就可以进行一些自由的定制了，比如设置连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等。这部分内容根据自己的实际情况进行编写，示例写法如下: 1connection.setConnectTimeout(8000); connection.setReadTimeout(8000); 4. 获取服务器发送过来的信息调用 getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取，如下所示: 12345678910111213InputStream in = connection.getInputStream();reader = new BufferedReader(new InputStreamReader(in));StringBuilder response = new StringBuilder();String line;while ((line = reader.readLine()) != null) &#123; response.append(line);&#125;``` ### 5. 关闭连接最后可以调用 disconnect()方法将这个 HTTP 连接关闭掉，如下所示:```javaconnection.disconnect(); 6. 小试牛刀：NetworkTest项目MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest = (Button) findViewById(R.id.send_request); responseText = (TextView) findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.send_request) &#123; sendRequestWithHttpURLConnection(); &#125; &#125; /** * */ private void sendRequestWithHttpURLConnection() &#123;// 开启线程来发起网络请求 new Thread(new Runnable() &#123; HttpURLConnection connection=null; BufferedReader reader=null; @Override public void run() &#123; try &#123; URL url=new URL("http://www.baidu.com"); connection= (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(5000); //对获取到的输入流进行读取 InputStream in =connection.getInputStream(); reader=new BufferedReader(new InputStreamReader(in)); StringBuilder response=new StringBuilder(); String line; while ((line=reader.readLine())!=null)&#123; response.append(line); &#125; // 显示收到的数据 showResponse(response.toString()); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response)&#123; //UI的线程 runOnUiThread runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //这里进行UI的操作，将结果显示到界面上 responseText.setText(response); &#125; &#125;); &#125;&#125; activity_mian.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.gaoshiwei.networktest.MainActivity"&gt; &lt;Button android:id="@+id/send_request" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/send_request" android:textAllCaps="false"/&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/response_text" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/ScrollView&gt;&lt;/android.support.constraint.ConstraintLayout&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android--通知(Notification)]]></title>
      <url>%2F2017%2F04%2F19%2FAndroid--Notification%2F</url>
      <content type="text"><![CDATA[Android–通知(Notification)通知是一个功能通知(Notification)是 Android 系统中比较有特色的一个功能，当某个应用程序希望向 用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。发出一 条通知后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。 通知的使用 通知的用法比较灵活.可以在活动中创建，也可以在广播接收器里创建，也可以在服务中创建。相比于广播接收器和服务，在活动里创建通知的场景还是比较少的， 因为一般只有当程序进入到后台的时候我们才需要使用通知 。 创建的步骤无论哪种方式，整体的创建步骤都是相同的 1，创建NotificationManager首先需要一个NotificationManager来对通知进行管理。可以调用 Context 的 getSystemService()方法获取到。getSystemService()方法接收一个字符串参数用于确定获取系 统的哪个服务，这里我们传入 Context.NOTIFICATION_SERVICE 即可。因此，获取NotificationManager 的实例就可以写成： 1NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); 2,使用一个Builder构造器来创建Notification对象几乎Android系统的每个版本都会对通知这部分功能进行或多或少的修改，API不稳定性问题在通知上面突出尤其严重。如何解决这个问题呢？就是使用support库中提供的兼容APIsupport-v4库中提供了一个NotificationCompat类，使用这个类的构造器来创建Notification对象，就可以保证在所有Android版本上正常工作。 1Notification notification = new NotificationCompat.Builder(context).build(); 上述的代码创建了一个空的Notification对象，并没有什么实际的作用。我们可以在最终build()方法之前连缀任意多的设置方法来创建一个丰富的Notification对象 12345678Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is a content title") .setContentText("This is Content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .build(); //setXXX的意思，看英文名就能知道是什么意思了。不在解释了。 3,使用这个通知只需要调用NotificationManager的notify()方法就可以了 Demo12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendButton = (Button) findViewById(R.id.send_notification); sendButton.setOnClickListener(this); &#125; /** * 创建通知的Demo * 先创建NotificationManager 对象 * 在创建Notification的对象，并进行设置 * 设置完成后使用NotificationManager的notify方法 * date 20170419 * * @param v */ @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notification: NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is a content title") .setContentText("This is Content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .build();// 使用manager的notify方法。第一个参数是ID，要保证每个通知的ID都是不同的 manager.notify(1, notification); break; default: break; &#125; &#125;&#125; 如果你使用过 Android 手机，此时应该会下意识地认为这条通知是可以点击的。但是当 你去点击它的时候，你会发现没有任何效果。不对啊，好像每条通知点击之后都应该会有反 应的呀?其实要想实现通知的点击效果，我们还需要在代码中进行相应的设置，这就涉及到 了一个新的概念，PendingIntent。 设置点击效果PendingIntentPendingIntent 从名字上看起来就和 Intent 有些类似，它们之间也确实存在着不少共同点。 比如它们都可以去指明某一个“意图”，都可以用于启动活动、启动服务以及发送广播等。 不同的是，Intent 更加倾向于去立即执行某个动作，而 PendingIntent 更加倾向于在某个合适 的时机去执行某个动作。所以，也可以把 PendingIntent 简单地理解为延迟执行的 Intent。 PendingIntent 的用法同样很简单，它主要提供了几个静态方法用于获取 PendingIntent 的实例，可以根据需求来选择是使用 getActivity()方法、getBroadcast()方法、还是 getService() 方法。 这几个方法所接收的参数都是相同的. 第一个参数依旧是 Context，不用多做解释。 第二个参数一般用不到，通常都是传入0即可。 第三个参数是一个 Intent 对象，我们可以通过这个对象构建出 PendingIntent 的“意图”。 第四个参数用于确定 PendingIntent 的行为，有 FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT 和 FLAGUPDATE CURRENT 这四种值可选，每种值的含义你可以查看文档，通常的情况下这个参数传入0就可以了。 对PendingIntent 有了一定的了解后，我们再回过头来看一下NotificationCompat.Builder。这个构造器还可以在连缀一个setContentIntent()方法。接收参数正是一个 PendingIntent 对象。因此，这里 就可以通过 PendingIntent 构建出一个延迟执行的“意图”，当用户点击这条通知时就会执行 相应的逻辑。修改之前的代码： 123456789101112131415161718192021222324 public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notification: Intent intent = new Intent(this, NotificationActivity.class);//增加点击效果的代码 PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);//增加点击效果的代码 NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is a content title") .setContentText("This is Content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi) .setAutoCancel(true)//点击后自动取消状态栏的图标。还有一种写法，我写在了NotificationActivity中 .build();// 使用manager的notify方法。第一个参数是ID，要保证每个通知的ID都是不同的 manager.notify(1, notification); break; default: break; &#125; &#125; 另外一种取消图标的方式12345678910111213141516171819202122public class NotificationActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_notification);/** *另外一种点击后取消状态栏图标的方法 * * 可以看到，这里我们在 cancel()方法中传入了 1， * 这个 1 是什么意思呢? * 还记得在创建通 知的时候给每条通知指定的 id 吗? * 当时我们给这条通知设置的 id 就是 1。因此，如果你想要取消哪一条通知，就在 cancel()方法中传入该通知的 id 就行了。 * 当我们使用PendingIntent让通知的响应来到这个Activity的时候，但是巧的是我们的代码写在oncreate中，所以当点击的时候就会有通知栏消失的现象。 */ NotificationManager manager= (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.cancel(1); &#125;&#125; 高级使用和优化。代码如下，注释是很好的解释。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.example.gaoshiwei.notificationtest;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Intent;import android.graphics.BitmapFactory;import android.graphics.Color;import android.net.Uri;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.support.v7.app.NotificationCompat;import android.view.View;import android.widget.Button;import java.io.File;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendButton = (Button) findViewById(R.id.send_notification); sendButton.setOnClickListener(this); &#125; /** * 创建通知的Demo * 先创建NotificationManager 对象 * 在创建Notification的对象，并进行设置 可以在.build();前写一系列想要的设定效果，显示信息等。 * 设置完成后使用NotificationManager的notify方法 * date 20170419 * * @param v */ @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notification: Intent intent = new Intent(this, NotificationActivity.class);//增加点击效果 PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);//增加点击效果 NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this)// 都是setXXX 很有规律性 .setContentTitle("This is a content title") .setContentText("This is Content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi)// 使用一些常用的通知效果 .setSound(Uri.fromFile(new File("/system/media/audio/ringtones/Luna.ogg/")))//sound .setVibrate(new long[]&#123;0, 1000, 1000, 1000&#125;)//vibrate .setLights(Color.GREEN, 1000, 1000)// crash lights// 简便的写法，使用通知的默认效果// .setDefaults( NotificationCompat.DEFAULT_ALL)// 使用高级功能 setStyle功能。 .setStyle(new NotificationCompat.BigTextStyle().bigText("记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭.")) //.setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.chifan)))// 设置优先级,合理使用优先级 .setPriority(NotificationCompat.PRIORITY_DEFAULT)// 点击后自动取消状态栏的图标。还有一种写法，我写在了NotificationActivity中 .setAutoCancel(true) .build();// 使用manager的notify方法。第一个参数是ID，要保证每个通知的ID都是不同的 manager.notify(1, notification); break; default: break; &#125; &#125;&#125; 此Demo的源代码传送门Github]]></content>
    </entry>

    
  
  
</search>
