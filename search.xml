<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android -- 使用网络技术]]></title>
      <url>%2F2017%2F04%2F23%2FAndroid-%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[Android – 使用网络技术!!!提醒，在开发中，时刻要注意权限的问题。使用网络，是要产生流量数据的，所以别忘了申请网络权限。在AndroidManifest.xml中添加相应的权限 使用HttpURLConnection（Google官方） 在 Android 上发送 HTTP 请求的方式一般有两种。 HttpURLConnection （官方建议） HttpClient （6.0以后已经移除） 来学习一下 HttpURLConnection 的用法。1. 首先需要获取到 HttpURLConnection 的实例.一般只需 new 出一个 URL 对象，并传入 目标的网络地址，然后调用一下 openConnection()方法即可，如下所示:URL url = new URL(&quot;http://www.baidu.com&quot;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); 2. 得到了 HttpURLConnection 的实例之后，我们可以设置一下 HTTP 请求所使用的方法。 常用的方法主要有两个，GET 和 POST。GET 表示希望从服务器那里获取数据，而 POST 则 表示希望提交数据给服务器。写法如下:connection.setRequestMethod(&quot;GET&quot;); 3. 接下来就可以进行一些自由的定制了，比如设置连接超时、读取超时的毫秒数，以及服 务器希望得到的一些消息头等。这部分内容根据自己的实际情况进行编写，示例写法如下:connection.setConnectTimeout(8000); connection.setReadTimeout(8000); 4. 之后再调用 getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取，如下所示:InputStream in = connection.getInputStream(); 5. 关闭连接最后可以调用 disconnect()方法将这个 HTTP 连接关闭掉，如下所示: connection.disconnect(); 6. 小试牛刀：NetworkTest项目MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.example.gaoshiwei.networktest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest = (Button) findViewById(R.id.send_request); responseText = (TextView) findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.send_request) &#123; sendRequestWithHttpURLConnection(); &#125; &#125; /** * */ private void sendRequestWithHttpURLConnection() &#123;// 开启线程来发起网络请求 new Thread(new Runnable() &#123; HttpURLConnection connection=null; BufferedReader reader=null; @Override public void run() &#123; try &#123; URL url=new URL("http://www.baidu.com"); connection= (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(5000);// 对获取到的输入流进行读取 InputStream in =connection.getInputStream(); reader=new BufferedReader(new InputStreamReader(in)); StringBuilder response=new StringBuilder(); String line; while ((line=reader.readLine())!=null)&#123; response.append(line); &#125;// 显示收到的数据 showResponse(response.toString()); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response)&#123;//UI的线程 runOnUiThread runOnUiThread(new Runnable() &#123; @Override public void run() &#123;// 这里进行UI的操作，将结果显示到界面上 responseText.setText(response); &#125; &#125;); &#125;&#125; 解释一下代码可以看到，我们在 Send Request 按钮的点击事件里调用了 sendRequestWithHttpURL- Connection()方法，在这个方法中先是开启了一个子线程，然后在子线程里使用 HttpURL- Connection 发出一条 HTTP 请求，请求的目标地址就是百度的首页。接着利用 BufferedReader 对 服务器返回的流进行读取，并将结果传入到了 showResponse()方法中。而在 showResponse() 方法里则是调用了一个 runOnUiThread()方法，然后在这个方法的匿名类参数中进行操作，将 返回的数据显示到界面上。那么这里为什么要用这个 runOnUiThread()方法呢?这是因为 Android 是不允许在子线程中进行 UI 操作的，我们需要通过这个方法将线程切换到主线程，然后 再更新 UI 元素。现在你只需要记得必须 这么写就可以了。 activity_mian.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.gaoshiwei.networktest.MainActivity"&gt; &lt;Button android:id="@+id/send_request" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/send_request" android:textAllCaps="false"/&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/response_text" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/ScrollView&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 7.提交数据给服务器只需要将HTTP的请求方式改为POST.并在获取输入流之前将要吧提交的数据写出即可。每条数据是键值对形式，数据与数据之间用&amp; 隔开. Demo： 123connection.setRequestMethod("POST");DataOutputStream out=new DataOutputStream(connection.getOutputStream());out.writerByte("username=admin&amp;password=123456"); 使用OkHttp(不错的开源框架) OkHttp传送门 开始使用 1. 添加OkHttp库的依赖，编辑app/build.gradle文件，在dependencies闭包中添加complie &apos;com.squareup.okhttp3:okhttp:XXX.XXX.XXX&apos; XXX是版本号 添加上述依赖会自动下载两个库，一个是 OkHttp 库，一个是 Okio 库，后者是前者的通信基础。 2. 学习基本的使用1. 首先需要创建一个 OkHttpClient 的实例，如下所示:1OkHttpClient client = new OkHttpClient(); 2. 接下来如果想要发起一条 HTTP 请求，就需要创建一个 Request 对象:1Request request = new Request.Builder().build(); 当然，上述代码只是创建了一个空的 Request 对象，并没有什么实际作用，我们可以在最终的 build()方法之前连缀很多其他方法来丰富这个 Request 对象。比如可以通过 url()方法 来设置目标的网络地址，如下所示: 123Request request = new Request.Builder() .url("http://www.baidu.com") .build(); 3, 之后调用 OkHttpClient 的 newCall()方法来创建一个 Call 对象，并调用它的 execute()方法来发送请求并获取服务器返回的数据.写法如下:1Response response = client.newCall(request).execute(); 4，获取数据其中 Response 对象就是服务器返回的数据了，我们可以使用如下写法来得到返回的具体内容: 1String responseData = response.body().string(); 5，POST类型的请求如果是发起一条 POST 请求会比 GET 请求稍微复杂一点，我们需要先构建出一个 Request Body 对象来存放待提交的参数，如下所示: RequestBody requestBody = new FormBody.Builder() .add("username", "admin") .add("password", "123456") .build(); 然后在 Request.Builder 中调用一下 post()方法，并将 RequestBody 对象传入: Request request = new Request.Builder() .url("http://www.baidu.com") .post(requestBody) .build(); 接下来的操作就和 GET 请求一样了，调用 execute()方法来发送请求并获取服务器返回的 数据即可。 实战Demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.example.gaoshiwei.myokhttptest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.io.IOException;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest = (Button) findViewById(R.id.send_request); responseText = (TextView) findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.send_request) &#123; sendRequestWithOkHttp(); &#125; &#125; /** * 使用OKhttp */ private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("http://www.baidu.com") .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); showResponse(responseData); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response) &#123;//UI的线程 runOnUiThread.// 此处建议深度理解一下。// runOnUiThread(new Runnable() &#123; @Override public void run() &#123;// 这里进行UI的操作，将结果显示到界面上 responseText.setText(response); &#125; &#125;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Andrdoid--通知(Notification)]]></title>
      <url>%2F2017%2F04%2F19%2FAndrdoid-%E9%80%9A%E7%9F%A5-Notification%2F</url>
      <content type="text"><![CDATA[Andrdoid–通知(Notification)通知是一个功能通知(Notification)是 Android 系统中比较有特色的一个功能，当某个应用程序希望向 用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。发出一 条通知后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。 通知的使用 通知的用法比较灵活.可以在活动中创建，也可以在广播接收器里创建，也可以在服务中创建。相比于广播接收器和服务，在活动里创建通知的场景还是比较少的， 因为一般只有当程序进入到后台的时候我们才需要使用通知 。 创建的步骤无论哪种方式，整体的创建步骤都是相同的 1，创建NotificationManager首先需要一个NotificationManager来对通知进行管理。可以调用 Context 的 getSystemService()方法获取到。getSystemService()方法接收一个字符串参数用于确定获取系 统的哪个服务，这里我们传入 Context.NOTIFICATION_SERVICE 即可。因此，获取NotificationManager 的实例就可以写成： NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); 2,使用一个Builder构造器来创建Notification对象几乎Android系统的每个版本都会对通知这部分功能进行或多或少的修改，API不稳定性问题在通知上面突出尤其严重。如何解决这个问题呢？就是使用support库中提供的兼容APIsupport-v4库中提供了一个NotificationCompat类，使用这个类的构造器来创建Notification对象，就可以保证在所有Android版本上正常工作。 Notification notification = new NotificationCompat.Builder(context).build();上述的代码创建了一个空的Notification对象，并没有什么实际的作用。我们可以在最终build()方法之前连缀任意多的设置方法来创建一个丰富的Notification对象 12345678Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is a content title") .setContentText("This is Content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .build(); //setXXX的意思，看英文名就能知道是什么意思了。不在解释了。 3,使用这个通知只需要调用NotificationManager的notify()方法就可以了 Demo12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendButton = (Button) findViewById(R.id.send_notification); sendButton.setOnClickListener(this); &#125; /** * 创建通知的Demo * 先创建NotificationManager 对象 * 在创建Notification的对象，并进行设置 * 设置完成后使用NotificationManager的notify方法 * date 20170419 * * @param v */ @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notification: NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is a content title") .setContentText("This is Content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .build();// 使用manager的notify方法。第一个参数是ID，要保证每个通知的ID都是不同的 manager.notify(1, notification); break; default: break; &#125; &#125;&#125; 如果你使用过 Android 手机，此时应该会下意识地认为这条通知是可以点击的。但是当 你去点击它的时候，你会发现没有任何效果。不对啊，好像每条通知点击之后都应该会有反 应的呀?其实要想实现通知的点击效果，我们还需要在代码中进行相应的设置，这就涉及到 了一个新的概念，PendingIntent。 设置点击效果PendingIntentPendingIntent 从名字上看起来就和 Intent 有些类似，它们之间也确实存在着不少共同点。 比如它们都可以去指明某一个“意图”，都可以用于启动活动、启动服务以及发送广播等。 不同的是，Intent 更加倾向于去立即执行某个动作，而 PendingIntent 更加倾向于在某个合适 的时机去执行某个动作。所以，也可以把 PendingIntent 简单地理解为延迟执行的 Intent。 PendingIntent 的用法同样很简单，它主要提供了几个静态方法用于获取 PendingIntent 的实例，可以根据需求来选择是使用 getActivity()方法、getBroadcast()方法、还是 getService() 方法。 这几个方法所接收的参数都是相同的. 第一个参数依旧是 Context，不用多做解释。 第二个参数一般用不到，通常都是传入0即可。 第三个参数是一个 Intent 对象，我们可以通过这个对象构建出 PendingIntent 的“意图”。 第四个参数用于确定 PendingIntent 的行为，有 FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT 和 FLAGUPDATE CURRENT 这四种值可选，每种值的含义你可以查看文档，通常的情况下这个参数传入0就可以了。 对PendingIntent 有了一定的了解后，我们再回过头来看一下NotificationCompat.Builder。这个构造器还可以在连缀一个setContentIntent()方法。接收参数正是一个 PendingIntent 对象。因此，这里 就可以通过 PendingIntent 构建出一个延迟执行的“意图”，当用户点击这条通知时就会执行 相应的逻辑。修改之前的代码： 123456789101112131415161718192021222324 public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notification: Intent intent = new Intent(this, NotificationActivity.class);//增加点击效果的代码 PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);//增加点击效果的代码 NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is a content title") .setContentText("This is Content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi) .setAutoCancel(true)//点击后自动取消状态栏的图标。还有一种写法，我写在了NotificationActivity中 .build();// 使用manager的notify方法。第一个参数是ID，要保证每个通知的ID都是不同的 manager.notify(1, notification); break; default: break; &#125; &#125; 另外一种取消图标的方式123456789101112131415161718192021public class NotificationActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_notification);/** *另外一种点击后取消状态栏图标的方法 * * 可以看到，这里我们在 cancel()方法中传入了 1， * 这个 1 是什么意思呢? * 还记得在创建通 知的时候给每条通知指定的 id 吗? * 当时我们给这条通知设置的 id 就是 1。因此，如果你想要取消哪一条通知，就在 cancel()方法中传入该通知的 id 就行了。 */ NotificationManager manager= (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.cancel(1); &#125;&#125; 高级使用和优化。代码如下，注释是很好的解释。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.example.gaoshiwei.notificationtest;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Intent;import android.graphics.BitmapFactory;import android.graphics.Color;import android.net.Uri;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.support.v7.app.NotificationCompat;import android.view.View;import android.widget.Button;import java.io.File;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendButton = (Button) findViewById(R.id.send_notification); sendButton.setOnClickListener(this); &#125; /** * 创建通知的Demo * 先创建NotificationManager 对象 * 在创建Notification的对象，并进行设置 可以在.build();前写一系列想要的设定效果，显示信息等。 * 设置完成后使用NotificationManager的notify方法 * date 20170419 * * @param v */ @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notification: Intent intent = new Intent(this, NotificationActivity.class);//增加点击效果 PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);//增加点击效果 NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this)// 都是setXXX 很有规律性 .setContentTitle("This is a content title") .setContentText("This is Content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi)// 使用一些常用的通知效果 .setSound(Uri.fromFile(new File("/system/media/audio/ringtones/Luna.ogg/")))//sound .setVibrate(new long[]&#123;0, 1000, 1000, 1000&#125;)//vibrate .setLights(Color.GREEN, 1000, 1000)// crash lights// 简便的写法，使用通知的默认效果// .setDefaults( NotificationCompat.DEFAULT_ALL)// 使用高级功能 setStyle功能。 .setStyle(new NotificationCompat.BigTextStyle().bigText("记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭." + "记得吃饭，吃饭 ，吃饭.")) //.setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.chifan)))// 设置优先级,合理使用优先级 .setPriority(NotificationCompat.PRIORITY_DEFAULT)// 点击后自动取消状态栏的图标。还有一种写法，我写在了NotificationActivity中 .setAutoCancel(true) .build();// 使用manager的notify方法。第一个参数是ID，要保证每个通知的ID都是不同的 manager.notify(1, notification); break; default: break; &#125; &#125;&#125; 此Demo的源代码传送门Github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C语言--指针]]></title>
      <url>%2F2017%2F04%2F17%2FC%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88%2F</url>
      <content type="text"><![CDATA[谈谈指针指针是什么？指针是一种保存变量地址的变量。 指针和地址指针是能够存放一个地址的一组存储单元。（通常是2个或4个字节） 一元运算符&amp;可用于去一个对象的地址。p=&amp;c; // p是一个指针变量 把c的地址赋值给变量p，我们称p为“指向”c的指针。 !!!地址运算符&amp;只能应用于内存中的对象，即变量和数组元素。不能作用于表达式，常量和register类型的变量 一元运算符*是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。x y 为整数。ip时指向int类型的指针。下面的代码将说明如何在程序中声明指针和如何使用&amp; ,* 运算符 &lt;Code&gt; int x=1,y=2,z[10]; int *ip; /* ip是指向int类型的指针 */ ip = &amp;x; /* ip现在指向x，ip是x的指针变量，*ip代表的就是x，即*ip等价x */ y = *ip; /* y的值现在为1 *ip就是x */ *ip=0; /* x的值现在为0 */ ip=&amp;z[0]; /* ip现在指向z[0] */ 指针的声明1 变量上的声明int *ip; //该声明语句声明表达式*ip的结果是int类型 2 对函数的声明（第二个才是函数的声明，第一个只是为了，说明和变量的声明差不多）double *dp,atof(char *); 在表达式中，*dp 和atof（s)的值都是double类型，且atof的参数是一个指向char类型的指针。 我们应该注意，指针智能指向某种特定的类型的对象，也就是说，每个指针都必须指向某特定的数据类型。（一个例外情况是指向void类型的指针可以存放指向任何类型的指针，但他不能间接引用自身。） 指针的使用如果指针ip指向整型变量x，那么在可以出现的任何上下文中都可以使用*ip，因此语句 *ip=*ip+10; //将*ip的值增加10 一元运算符*和&amp;的优先级比算术运算符优先级高。 y=*ip+1; //将*ip指向的对象的值取出并加1，再将结果赋值给y *ip+=1;//等价于下面的表达式 ++*ip;//或（*ip)++; 说明一点，由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用的方法使用。 如果iq是另一个指向整型的指针，那么语句 iq=ip; 将把ip中的值copy到iq中，这样，指针iq也将指向ip的对象。]]></content>
    </entry>

    
  
  
</search>
